# build_210000000.R
# 
# REMOVE >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# [This is a template build script for running EML assembly line to create a
# data package for EDI. You can safely remove this section for packages 
# other than the template package (all zeros)]
# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
#
# After creating the EML with this script, the EML file and data entities
# should be uploaded to EDI (staging first) at:
#
# http://portal-s.lternet.edu/nis/harvester.jsp (Evaluate/Upload Packages tool)
#
# EMLassemblyline instructions (including links to vocab) here:
#
# https://ediorg.github.io/EMLassemblyline
# 
# !!!!!!!!!
# When running this script on the shared drive it may be necessary to set the 
# path based on how you map the drive. i.e.:
#
# setwd('/Volumes/JornadaFiles/LTER_IM/JRN_EMLassemblyline/pkg210.../')
# setwd('Z:\\DataProducts\LTER_IM....
# !!!!!!!!!

# Set the working directory here (could be a local or network share path):
setwd('/Volumes/DataProducts/LTER_IM/210000000_template/')
# If in rstudio this will set the working directory to the dir containing
# the build script
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))

library('EMLassemblyline')
library(tidyverse)

#Dataset title (what where when)
datasettitle <- "Example data package for testing emlassemblyline (mtcars)"

# Paths to metadata templates, data entities, and eml
datafiles <- c("mtcars.csv")      # Data entity file names
datafile_names <- c("Subsetted data") # Name of data entity
datafile_desc <- c("Subset of columns from R mtcars dataset") # Longer desc
mtpath <- "./metadata_templates"  # Path to metadata templates
dpath <- "./data_entities"        # Path to data entities
data_url <- 'https://storage.googleapis.com/jrn-data-entities' # A publicly accessible URL to the data
emlpath <- "./eml"                # Path to output eml to

# Describe the maintenance, and temporal  coverage. 
# Temporal coverage can be autogenerated if exported dataframe
# (df.export) has a date column
maintenance_desc <- 'completed'
temp_cov <- c('2018-01-01', '2019-01-01') # change to "auto" to autogenerate

# If other entities
#otherents <- c('otherent.pdf')
#otherent_names <- c('name of otherent file')
#otherent_desc <- c('describe the otherent')

# Revision of data packages on EDI.
# Increment by 1 when uploading to EDI
revision <- 8 # Staging=7, EDI=?


# Load mtcars, create a new column with the rownames, remove some columns,
# and export a simplified dataframe as csv (without rownames)
cars <- mtcars 
cars$type <- row.names(cars)

df.export <- cars %>%
  dplyr::select(type, mpg, wt, cyl, gear)

# In more complex cases with a csv you may want to assign data type
#df_in <- read_csv('Tromble_Weir_Precip_data_EDI.csv',
#                  col_types = cols(Year = col_character(),
#                                   Month = col_character(),
#                                   Day = col_character(),
#                                   Hour = col_character(),
#                                   Minute = col_character(),
#                                   Second = col_character()))

# Mutating columns is good sometimes also
#df.export <- df_in %>%
#  mutate(date = as.Date(paste(Year,Month,Day,Hour,Minute,Second, sep='-'),
#                        format="%Y-%m-%d-%H-%M-%S")) %>%
#  select(date, R_tower, R2, R3, R4)

# Check for NAs and unique values of catvars
sapply(df.export, function(x) sum(is.na(x)))
unique(df.export$type)

# Export df.export as a csv to 'pathname'
options(scipen=999)   # turns of scientific notation
write.csv(df.export, paste0(dpath, '/', datafiles[1]), quote=F, row.names=F)
#write_csv(df.export, paste0(dpath, '/', datafiles[1]))

# Import the metadata from the template files. If there are no template files
# empty ones will be created where specified
#
# WARNING: If docx or md templates have been created, this command will
# create empty methods.txt, abstract.txt, and potentially other templates.
# (It can be commented out or changed to 'write.file=FALSE')
template_core_metadata(path = mtpath,
                       license = "CCBY",
                       x=NULL, #Not sure what this does
                       write.file=TRUE)

# Create data attributes (variables) template
template_table_attributes(path = mtpath,
                          data.path = dpath,
                          data.table = datafiles)

# Create categorical variables template
template_categorical_variables(path = mtpath,
                               data.path = dpath)

# This function can be used to assign geographic coordinates
# to particular entities in the dataset if they have name, latitudes, and
# longitudes. It is a little easier (given our constraints on sharing 
# geographic info at the Jornada) to just create an empty template and 
#define bounding boxes within it.
template_geographic_coverage(path=mtpath, empty=TRUE)
#  path = mtpath,
#  data.path = dpath,
#  data.table = datafiles,
#  site.col = 'site_name',
#  lat.col = 'site_lat',
#  lon.col = 'site_lon')

# Autogenerate the temporal coverage element if requested
if(temp_cov == "auto") {
    temp_cov <- c(min(df.export$date, na.rm=T), 
                  max(df.export$date, na.rm=T))
}

# Make the EML file - some metadata elements are filled in here, along with the
# scope and complete packageid.
emlout <- make_eml(path = mtpath,
                   dataset.title = datasettitle,
                   data.path = dpath,
                   data.table = datafiles,
                   data.table.name = datafile_names,
                   data.table.description = datafile_desc,
                   #other.entity = otherents,
                   #other.entity.name = otherent_names,
                   #other.entity.description = otherent_desc,
                   eml.path = emlpath,
                   temporal.coverage = temp_cov,
                   maintenance.description = maintenance_desc,
                   #data.url = data_url, #this works the best
                   #data.table.url = data_url,
                   #other.entity.url = c(data_url),
                   user.id = "JRN",
                   user.domain = "LTER",
                   package.id = paste0("knb-lter-jrn.210000000.", revision),
                   return.obj = T) # Returns eml as a named list (for editing)

# PLEASE READ: Sometimes there is still invalid EML produced if there are
# quotes in text templates document (a bug?). If EMLassemblyline says the
# EML did not pass validation, this may be the problem. To fix, <quote> tags 
# need to be edited out in Oxygen. This issue would occur if using quoted 
# text in methods, abstract, or other text templates **in .txt file formats**.

# You can escape (\") or remove the quotes in the plain text templates before 
# generating the eml to avoid the error - whichever is easier.
